## Synchronized

 https://www.jianshu.com/p/d53bf830fa09 

CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：**V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值**。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程

##  volatile 

 volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。 

### 1、volatile 的特性

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）
- 禁止进行指令重排序。（实现有序性）
- volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。

### 2、内存可见性实现

- volatile 变量的内存可见性是基于内存屏障（Memory Barrier）实现。
  - 内存屏障，又称内存栅栏，是一个 CPU 指令。
  - 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。
- lock 前缀的指令在多核处理器下会引发两件事情。 
  - 1）将当前处理器缓存行的数据写回到系统内存。
  - 2）写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。
- 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作，但操作完不知道何时会写到内存。
- 如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
- 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 
  - 所有多核处理器下还会完成：3）当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
- volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。

## 进程和线程

 https://www.jianshu.com/p/2dc01727be45 

## LeetCode

https://leetcode.com/discuss/career/448285/List-of-questions-sorted-by-common-patterns

## HTTP

 https://www.cnblogs.com/ranyonsue/p/5984001.html 

```
GET     请求指定的页面信息，并返回实体主体。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
```

我们看看GET和POST的区别

1. 1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.
   2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
   3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

## 双亲委派模型

 https://www.jianshu.com/p/9df9d318e838 

## 自我介绍

面试官好，我叫刘旭，今年24岁，就读于北京邮电大学信息与通信工程专业，硕士期间的研究方向是边缘计算与计算卸载。对Java语言和编程开发有过相应的学习，熟悉Java语言基础，熟悉Java常用的数据结构和JVM和并发的相关知识。此外，对于MVC设计模式，一些常用的框架，例如springboot， mybatis等，以及数据库的相关知识也有过了解。对于算法也有一定的掌握。

我此前在实验室有过两个项目，第一个是我自己学习并搭建的员工信息管理系统，基于springboot和mybatis框架，实现员工信息的增删改查和展示。另一个是实验室的低轨卫星边缘计算项目，主要负责相应的计算卸载流程设计和实现，整个项目用于展示实验室的相关研究成果，能够演示低轨卫星场景下的计算卸载与迁移方案。

对于我个人而言，本人勤恳踏实，乐于钻研并且也有很强的团队协作精神。虽然我没有很多的实习实践经历，但是我觉得基于我相应的基础和勤恳好学的精神，我能够胜任公司的相应岗位。以上就是我的个人介绍，谢谢。

## OOM

Java虚拟机OutOfMemoryError 异常

1、**程序计数器**不存在OOM异常

2、**Java虚拟机栈**中，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

**注意到：**HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟
机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不
会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。

3、**本地方法栈**也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常

4、**Java堆**中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常

5、**方法区**无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

6、**运行时常量池**是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存
时会抛出OutOfMemoryError异常。

7、**直接内存**的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到
本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务
器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得
各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现
OutOfMemoryError异常。

## Java特性

 https://juejin.im/entry/59f292635188254115701364 

### 1、抽象

抽象就是将一类实体的共同特性抽象出来，封装在一个新的概念(类) 中，所以抽象是面向对象语言的基础。 

### 2、封装

 在面向对象语言中，封装特性是由类来体现的。我们将现实生活中的一类实体定义成类，其中包括属性和行为（在Java中就是方法），就好像人类，可以具有name，gender，age等属性，同时也具有eat()，sleep()，我们在行为中实现一定的功能，也可操作属性，这是面向对象的封装特性；封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。 

 **封装的好处：**
  1、实现了专业的分工
  2、类内部的结构能够自由修改
  3、能够对成员进行更精确的控制
  4、隐藏信息，实现细节
  5、良好的封装能够减少耦合 

### 3、继承

 继承是一个对象获得另一个对象的属性的过程。 

 **继承的特征：**
  1、可传递可扩展。若类C继承类B，类B继承类A（多继承），则类C既有从类B那里继承下来的属性与方法，也有从类A那里继承下来的属性与方法，还可以有自己新定义的属性和方法。继承来的属性和方法尽管是隐式的，但仍是类C的属性和方法。
  2、可复用。若类B继承类A，那么建立类B时只需要再描述与基类(类A)不同的少量特征(数据成员和成员方法)即可。这种做法能减小代码和数据的冗余度，大大增加程序的重用性。
  3、可维护性。继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性。 

### 4、多态

 多态是允许一个接口被多个同类动作使用的特性，具体使用哪个动作与应用场合有关。多态就是通过传递给父类对象引用不同的子类对象从而表现出不同的行为，多态可为程序提供更好的可扩展性，同样也可以代码重用。 

## cookie、session、token

 https://juejin.im/post/5aede266f265da0ba266e0ef 

 https://juejin.im/post/5d01f82cf265da1b67210869 

### 1、cookie

cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据。跟服务器没啥关系，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器把cookie以KV形式存储到某个目录下的文本文件中，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。所以每个域的cookie数量是有限制的。

### 2、session

1.用户向服务器发送用户名和密码

2.服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等;

3.服务器向用户返回一个`session_id`, 写入用户的`cookie`

4.用户随后的每一次请求, 都会通过`cookie`, 将`session_id`传回服务器

5.服务端收到 `session_id`, 找到前期保存的数据, 由此得知用户的身份

### 3、token

用户登录请求登录接口时，验证用户名密码等，验证成功会返回给前端一个token，这个token就是之后鉴权的唯一凭证。

后台可能将token存储在redis或者数据库中。

之后前端的请求，需要在header中携带token，后端取出token去redis或者数据库中进行验证，如果验证通过则放行，如果不通过则拒绝操作。

## 锁优化

### 1、自旋锁

在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。

### 2、锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

### 3、锁粗化

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，

### 4、轻量级锁

HotSpot虚拟机的对象头（Object Header）分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。

![微信截图_20200312113313](D:\Users\12041\Desktop\学习\images\微信截图_20200312113313.png)

轻量级锁的工作过程了：

在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。

![微信截图_20200312113449](D:\Users\12041\Desktop\学习\images\微信截图_20200312113449.png)

虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图13-4所示。

![微信截图_20200312113538](D:\Users\12041\Desktop\学习\images\微信截图_20200312113538.png)

如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。

上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

### 5、偏向锁

偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。

一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。

## SpringBoot自动配置原理

 https://juejin.im/post/5ce5effb6fb9a07f0b039a14#heading-14 

@SpringBootApplication 

​	-@EnableAutoConfiguration

​		-@Import({AutoConfigurationImportSelector.class})

​			 getAutoConfigurationEntry() ：

​			 getAutoConfigurationEntry() -> getCandidateConfigurations() -> loadFactoryNames() 

​			loadFactoryNames() 中关键的三步：

1. 从当前项目的类路径中获取所有 `META-INF/spring.factories` 这个文件下的信息。
2. 将上面获取到的信息封装成一个 Map 返回。
3. 从返回的 Map 中通过刚才传入的 `EnableAutoConfiguration.class` 参数，获取该 key 下的所有值。

 将类路径下 `META-INF/spring.factories` 里面配置的所有 EnableAutoConfiguration 的值加入到 Spring 容器中。 

## 频繁GC优化

 https://tech.meituan.com/2017/12/29/jvm-optimize.html 